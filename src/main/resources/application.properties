spring.application.name=backend-template

# ============================================================
# SERVER
# ============================================================

server.port=8080

# Graceful shutdown: permite terminar las peticiones en curso antes de apagar la app
server.shutdown=graceful

# Tiempo máximo que el servidor espera a que terminen las peticiones pendientes al apagar
spring.lifecycle.timeout-per-shutdown-phase=30s

# Compresión HTTP: reduce tamaño de respuestas JSON grandes (listados paginados, etc.)
server.compression.enabled=true
server.compression.mime-types=application/json,application/xml,text/html,text/plain
server.compression.min-response-size=1024

# ============================================================
# DATASOURCE (PostgreSQL + HikariCP)
# ============================================================

# URL, usuario y contraseña externalizadas como variables de entorno (sensibles)
# En Render, las variables DB_HOST, DB_PORT, DB_NAME se inyectan desde el Blueprint
spring.datasource.url=jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:5432}/${DB_NAME:mydatabase}
spring.datasource.username=${DB_USERNAME:myuser}
spring.datasource.password=${DB_PASSWORD:secret}
spring.datasource.driver-class-name=org.postgresql.Driver

# HikariCP: pool de conexiones — evita abrir/cerrar conexiones en cada request
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
# Tiempo máximo que una conexión puede estar inactiva antes de ser descartada
spring.datasource.hikari.idle-timeout=300000
# Tiempo máximo de vida de una conexión (evita conexiones zombis por políticas del DB)
spring.datasource.hikari.max-lifetime=1200000
# Timeout para obtener una conexión del pool — falla rápido si el pool está saturado
spring.datasource.hikari.connection-timeout=20000
# Nombre del pool para identificarlo en métricas y logs
spring.datasource.hikari.pool-name=ECommerceHikariPool

# ============================================================
# JPA / HIBERNATE
# ============================================================

# ddl-auto=update es útil en dev; en producción usar 'validate' o 'none' con Flyway/Liquibase
spring.jpa.hibernate.ddl-auto=update
# Muestra SQL en consola para depuración — desactivar en producción
spring.jpa.show-sql=true
# SQL formateado legible en logs
spring.jpa.properties.hibernate.format_sql=true

# open-in-view=false: evita LazyInitializationException silenciosas y mejora el rendimiento
# al no mantener la sesión Hibernate abierta durante la renderización de la vista
spring.jpa.open-in-view=false

# Batch inserts/updates: agrupa operaciones DML para reducir roundtrips a la BD
spring.jpa.properties.hibernate.jdbc.batch_size=25
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true

# Genera estadísticas de Hibernate accesibles desde Actuator/Prometheus
spring.jpa.properties.hibernate.generate_statistics=false

# Estrategia de nombrado: convierte camelCase a snake_case automáticamente
spring.jpa.properties.hibernate.physical_naming_strategy=org.hibernate.boot.model.naming.CamelCaseToUnderscoresNamingStrategy

# ============================================================
# REDIS
# ============================================================

# URL de Redis: incluye host, puerto y contraseña en un solo string (sensible)
# Formato: redis://:password@host:port o redis://host:port (sin auth)
spring.data.redis.url=${REDIS_URL:redis://localhost:6379}
# Timeout de conexión al servidor Redis — falla rápido si Redis no responde
spring.data.redis.timeout=5000ms

# Lettuce pool: reutiliza conexiones a Redis en lugar de crear una por operación
spring.data.redis.lettuce.pool.enabled=true
spring.data.redis.lettuce.pool.max-active=8
spring.data.redis.lettuce.pool.max-idle=8
spring.data.redis.lettuce.pool.min-idle=2
# Tiempo máximo esperando una conexión del pool
spring.data.redis.lettuce.pool.max-wait=2000ms
# Intervalo entre chequeos de conexiones inactivas en el pool
spring.data.redis.lettuce.pool.time-between-eviction-runs=60s

# ============================================================
# CACHE (Redis-backed)
# ============================================================

spring.cache.type=redis
# TTL de 10 minutos: evita datos obsoletos sin sobrecargar Redis
spring.cache.redis.time-to-live=600000
# Prefijo de claves para evitar colisiones con otros servicios que usen el mismo Redis
spring.cache.redis.key-prefix=ecommerce:
spring.cache.redis.use-key-prefix=true
# No cachear valores null: evita almacenar búsquedas fallidas como resultados válidos
spring.cache.redis.cache-null-values=false

# ============================================================
# ACTUATOR + PROMETHEUS
# ============================================================

# Exponer endpoints esenciales: health, info, métricas, prometheus, caches, env
management.endpoints.web.exposure.include=health,info,metrics,prometheus,caches,env,loggers,mappings
# Base path personalizado para separar actuator del API de negocio
management.endpoints.web.base-path=/actuator

# Health: muestra detalles (db, redis, disk) solo a usuarios autenticados
management.endpoint.health.show-details=when-authorized
# Incluir checks de liveness/readiness para orquestadores (Kubernetes, Docker Swarm)
management.endpoint.health.probes.enabled=true
management.health.livenessstate.enabled=true
management.health.readinessstate.enabled=true

# Info: incluir datos del build, entorno, java y OS para diagnóstico
management.info.env.enabled=true
management.info.build.enabled=true
management.info.java.enabled=true
management.info.os.enabled=true
info.app.name=${spring.application.name}
info.app.description=Plantilla Backend para un E-commerce
info.app.version=0.0.1-SNAPSHOT

# Prometheus: habilitar exportación de métricas con etiquetas de la app
management.prometheus.metrics.export.enabled=true
# Etiquetas comunes para filtrar métricas por aplicación en Grafana/Prometheus
management.metrics.tags.application=${spring.application.name}
# Distribución de percentiles para métricas HTTP — útil en dashboards de latencia
management.metrics.distribution.percentiles-histogram.http.server.requests=true
management.metrics.distribution.slo.http.server.requests=50ms,100ms,200ms,500ms,1s

# ============================================================
# SECURITY
# ============================================================

# Credenciales del usuario por defecto (HTTP Basic) — SIEMPRE externalizar en producción
spring.security.user.name=${SECURITY_USER:admin}
spring.security.user.password=${SECURITY_PASSWORD:admin123}

# ============================================================
# RESILIENCE4J (Circuit Breaker)
# ============================================================

# --- Valores por defecto para todas las instancias de Circuit Breaker ---
# Ventana deslizante basada en conteo: evalúa las últimas N llamadas
resilience4j.circuitbreaker.configs.default.sliding-window-type=COUNT_BASED
# Tamaño de la ventana deslizante: analiza las últimas 10 llamadas
resilience4j.circuitbreaker.configs.default.sliding-window-size=10
# Llamadas mínimas antes de evaluar si el circuito debe abrirse
resilience4j.circuitbreaker.configs.default.minimum-number-of-calls=5
# Si el 50% de las llamadas fallan, el circuito se abre
resilience4j.circuitbreaker.configs.default.failure-rate-threshold=50
# Tiempo que el circuito permanece abierto antes de pasar a half-open
resilience4j.circuitbreaker.configs.default.wait-duration-in-open-state=30s
# Número de llamadas permitidas en estado half-open para probar si el servicio se recuperó
resilience4j.circuitbreaker.configs.default.permitted-number-of-calls-in-half-open-state=3
# Transición automática de open → half-open sin esperar una llamada
resilience4j.circuitbreaker.configs.default.automatic-transition-from-open-to-half-open-enabled=true
# Registrar el estado del health indicator en Actuator
resilience4j.circuitbreaker.configs.default.register-health-indicator=true

# Si las llamadas lentas superan el 100% del threshold, cuenta como fallo
resilience4j.circuitbreaker.configs.default.slow-call-rate-threshold=100
# Una llamada se considera lenta si tarda más de 3 segundos
resilience4j.circuitbreaker.configs.default.slow-call-duration-threshold=3s

# --- Retry: reintentar llamadas fallidas antes de declarar un fallo ---
resilience4j.retry.configs.default.max-attempts=3
# Espera entre reintentos
resilience4j.retry.configs.default.wait-duration=1s
# Backoff exponencial: duplica el tiempo de espera en cada reintento
resilience4j.retry.configs.default.enable-exponential-backoff=true
resilience4j.retry.configs.default.exponential-backoff-multiplier=2

# --- TimeLimiter: timeout máximo para operaciones asíncronas ---
resilience4j.timelimiter.configs.default.timeout-duration=5s
# Cancela el Future si se supera el timeout
resilience4j.timelimiter.configs.default.cancel-running-future=true

# Exponer estados de los circuit breakers en Actuator
management.health.circuitbreakers.enabled=true

# ============================================================
# JACKSON (Serialización JSON)
# ============================================================

# Fechas como ISO-8601 en lugar de timestamps numéricos — más legible en APIs REST
# spring.jackson.serialization.WRITE_DATES_AS_TIMESTAMPS=false
# No fallar si el JSON del cliente tiene campos que la API no reconoce — forward compatibility
spring.jackson.deserialization.fail-on-unknown-properties=false
# No incluir campos null en las respuestas JSON — reduce tamaño del payload
spring.jackson.default-property-inclusion=non_null

# ============================================================
# PAGINATION
# ============================================================

spring.data.web.pageable.default-page-size=20
spring.data.web.pageable.max-page-size=100
# Parámetro de página empieza en 0 (estándar Spring Data)
spring.data.web.pageable.one-indexed-parameters=false

# ============================================================
# CLOUDINARY
# ============================================================

# Credenciales de Cloudinary; OBLIGATORIO definir como variables de entorno en producción
cloudinary.cloud-name=${CLOUDINARY_CLOUD_NAME:your_cloud_name}
cloudinary.api-key=${CLOUDINARY_API_KEY:your_api_key}
cloudinary.api-secret=${CLOUDINARY_API_SECRET:your_api_secret}

# ============================================================
# MULTIPART (File Upload)
# ============================================================

# Tamaño máximo por archivo: 5MB razonable para imágenes de productos
spring.servlet.multipart.max-file-size=5MB
# Tamaño máximo total del request: permite imagen + JSON del producto
spring.servlet.multipart.max-request-size=10MB
# Umbral a partir del cual se escribe a disco en lugar de mantener en memoria
spring.servlet.multipart.file-size-threshold=2KB

# ============================================================
# ERROR HANDLING
# ============================================================

# No incluir el stacktrace en las respuestas de error — evita filtrar info interna
server.error.include-stacktrace=never
# Incluir el mensaje de error en la respuesta
server.error.include-message=always
# Incluir los errores de binding/validación
server.error.include-binding-errors=always



# ============================================================
# DEVTOOLS
# ============================================================

# LiveReload automático tras cambios en el código durante desarrollo
spring.devtools.livereload.enabled=true
# Archivos de recursos estáticos que no deben provocar restart
spring.devtools.restart.exclude=static/**,templates/**

# ============================================================
# LOGGING
# ============================================================

# Nivel raíz: INFO es adecuado para producción; usar DEBUG para troubleshooting
logging.level.root=INFO
# SQL detallado para depuración de queries JPA
logging.level.org.hibernate.SQL=DEBUG
# Ver los valores de los parámetros en los SQL (solo dev, desactivar en prod por seguridad)
logging.level.org.hibernate.orm.jdbc.bind=TRACE
# Logs del pool de conexiones — útil para detectar leaks o saturación
logging.level.com.zaxxer.hikari=INFO
# Logs de Spring Security para depurar autorización/autenticación
logging.level.org.springframework.security=INFO
# Logs de Resilience4j para monitorear estados de circuit breakers
logging.level.io.github.resilience4j=INFO
# Logs de la aplicación
logging.level.org.e_commerce.backend_template=DEBUG

# Patrón de log con timestamp, nivel, hilo, logger y mensaje
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n
# Archivo de log rotativo para entornos donde no hay agregador de logs centralizado
logging.file.name=logs/backend-template.log
logging.logback.rollingpolicy.max-file-size=10MB
logging.logback.rollingpolicy.max-history=30
logging.logback.rollingpolicy.total-size-cap=500MB
